# Homeworks-10m-2023

## Домашнее задание 3

0. С помощью `promise` реализуйте взаимодействие двух потоков, первый из которых ждет имени пользователя с клавиатуры, а второй (после его получения) выводит приветствие `Добро пожаловать, <username>`. Где <username> заменено на введенное имя соответственно.
1. Программа принимает на вход числа `n` и `s`. Требуется сгенерировать `n` случайных неотрицательных целых чисел $\le 100$, используя `s` как seed в функции random. \
Требуется вычислить факториалы этих чисел и вывести их в виде <число> : <факториал> по одному в строке. Для вычисления факториала нужно применить асинхронные задачи. 
2. Во входном файле `input.txt` заданы число `N` и `N` целых чисел, по модулю не больше $10^7$, требуется вычислить побитовый `xor` всех чисел. Для реализации требуется параллельно вычислять результат для разных групп чисел наиболее оптимально. Например, разделять группы на две части, а потом совмещать результат. Количество частей (k) и количество чисел (M), на котором стоит остановить деление выбирайте самостоятельно. 
(*) Дополнительно: проведите исследование, с какими параметрами (k и M) получается достичь лучшего результата по производительности. В качестве ответа принимается текстовый файл с результатами запусков на вашем устройстве. 

Для перемещения уже существующих объектов `std::future` может пригодиться функция `std::move`.

## Заметки

Часто некоторое вычисление можно выполнить параллельно, но результат применяется только вместе с дополнительной информацией родительского потока, а пока вычисления происходят, можно заняться чем-нибудь еще. \
Для работы с такими позже вычисленными данными в C++ есть `std::future`. Такой объект представляет собой будущий результат, то есть обертку, которая его хранит, в нужный момент можно запросить численное значение, но до этого момента он будет хранится закрытым. 

Для создания такого объекта существует функция `std::async`, которая запускает асинхронную задачу, то есть задачу, выполняющуюся в фоновом режиме. 

``
#include<future>

int f() {
    return 1 + 2;
}

int f_args(int x) {
    return 1 + x;
}

int main() {
    std::future<int> sum = std::async(f);
    std::future<int> sum_x = std::async(f, 10);
    // ...
}
``

Обратите внимание, что использование задач на будущее используется одноименная библиотека `future`. Дальше в примерах опустим подключение библиотек. \
Аналогично созданию потока можно передать аргументы исполняемой функции через запятую после ее указания.

Задачу можно запускать в двух режимах -- с помощью дополнительного потока или в этом же потоке при запросе результата. По-умолчанию режим оставляется на усмотрение реализации, но есть возможность задать его явно. \
* `deferred` соответствует синхронному запуску
* `async` -- асинхронному

``
int f() {
    return 1 + 2;
}

int f_args(int x) {
    return 1 + x;
}

int main() {
    std::future<int> sum = std::async(std::launch::deferred, f);
    std::future<int> sum_x = std::async(std::launch::async, f, 10);
    // ...
}
``
В качестве параметра шаблона `future` указывается тип результата.


Для получения значения используется метод `get`. Если результат еще не посчитан, то вызвавший поток останавливается и ждет выполнения задачи, после чего получает результат. \
После получения значения объект `future` уже нельзя использовать повторно. Также после первого вызова `get` значения в обертке не остается. \
Кроме того существует и метод `wait`, который аналогично функции `join` просто ожидает завершения задачи. \
Соответственно при вызове `get` или `wait` задачи, для которых задан синхронный способ запуска, будут выполнены.
``
#include<future>
#include<iostream>

int f() {
    return 1 + 2;
}


int main() {
    std::future<int> sum = std::async(f);
    // ..
    std::cout << sum.get();
}
``

`future` объекты не копируются, для использования в нескольких потоках существует `shared_future`. Его использование аналогично `future` , но значение не инвалидируется при вызове `get` и `wait` может использоваться параллельно. \
Также объекты такого класса уже копируются. Чтобы из обычного `future` получить `shared_future` существует метод `share`. Первоначальный объект передает владение данными новому `shared_future` и далее не может использоваться.

Для определения возможности использования `future` существует метод `valid`. Если результат `false`, поведение при дальнейшем использовании не определено.  

``
#include<future>

int f() {
    return 1 + 2;
}

int main() {
    std::future<int> sum = std::async(std::launch::async, f);
    std::shared_future<int> shared_sum(sum); // = sum.share();

    // sum.valid() == false
    // ...
}
``

Если мы хотим работать с несколькими разными задачами независимо от их происхождения задачами (и/или запускать синхронно в конкретном потоке), существует обертка еще более высокого уровня `std::packaged_task<>`. В качестве параметра шаблона принимается сигнатура функции. Например, для функции `f` это будет `int()`, а для `f_args` -- `int(int)`. \
В конструктор `packaged_task` можно передать вызываемый объект (аналогично потоку).

``
int f(int a, int b) {
    return a * b;
}

int main() {
    std::packaged_task<int(int,int)> task(f);
    std::future<int> f_result = task.get_future();
    //..
    task(10, 12);
    //...
    f_result.get();
}
``

Для запуска функции используются круглые скобки, а для получения будущего результата `get_future`. Результат является объектом класса `future`.

Для передачи значений между потоками также существует `std::promise`. С его помощью можно вручную сохранять значение и помечать его "готовым". Другой поток, используя уже известный нам механизм `future`, может его получить.

``
int main() {
    std::promise<int> prms;
    std::future<int> f_result = prms.get_future();
}
``

В примере выше мы создаем `promise`, который будет использоваться для добавления значения и с помощью метода `get_future` объект, из которого может быть получено это значение.

``
void f(std::promise<int> prms) {
    prms.set_value(1 + 2);
}

int main() {
    std::promise<int> prms;
    std::future<int> f_result = prms.get_future();

    std::thread t(f, std::move(prms));
    t.join();
    //...
    std::cout << f_result.get();
}
``