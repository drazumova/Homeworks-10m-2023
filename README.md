# Homeworks-10m-2023

## Дополнительное домашнее задание

Реализовать систему, иллюстрирующую любую из обсужденных проблем. Также требуется добавить блокировки для корректной работы.


## Классические задачи параллельного программирования

1. Задача об обедающих философах
Наверное, самая известная задача-проблема многопоточного программирования. Пять (или более) философов сидят за круглым столом и пытаются пообедать спагетти. Перед каждым из них стоит тарелка, между тарелками лежат вилки, есть человек может только двумя вилками. 
С вилками звучит не очень логично, давайте заменим их на палочки. 

Алгоритм действий каждого философа:
* Размышлять, пока не освободится левая вилка. Когда вилка освободится — взять её.
* Размышлять, пока не освободится правая вилка. Когда вилка освободится — взять её.
* Есть
* Положить левую вилку
* Положить правую вилку
* Повторить алгоритм сначала
  
Итак если все начинают есть одновременно, каждый возьмет по одной палочке и будет ждать, пока сосед отпустит вторую, что приведет к уже известной нам проблеме дедлока. 
Как это исправить мы также уже обсуждали, можно упорядочить вилки единым способом (от 1 до 5), тогда каждый философ должен сначала брать вилку с большим номером, потом с меньшим, и возвращать в обратном порядке.

Кроме того мы можем добавить фигуру официанта, который будет сообщать, можно ли брать вилку, без разрешения которого, состояния меняться не будут. Кроме того, таким образом можно обеспечить равномерное распределение ресурсов. Если мы видим, что соседи долго голодающего философа не дали ему поесть уже k раз подряд, то приоритет нужно выдать именно ему.

2. Проблема спящего парикмахера

В парикмахерской есть ровно один работник. Он стрижет клиентов, как только работа над очередным закончилась, он выходит в приемную и смотрит, есть ли в ней следующий человек. Если да, он приглашает его и продолжает работу, иначе садится на стул и засыпает. 
Если клиент приходит, пока парикмахер спит, он будит его и садится на стрижку, если же парикмахер занят, он идет на стул в приемной. Если же свободного стула для него нет, он уходит.

Задача заключается в синхронизации процессов, так как время на окончание стрижки, засыпание, приход нового клиента и стрижку не регламентировано. Парикмахер может дойти до приемной быстрее, чем туда доберется клиент, ушедший ожидать, таким образом потенциально потеряв клиента, которому не хватило стула, либо никого не найти и уйти спать в ожидании. Либо же два клиента могу одновременно попытаться занять последний стул в приемной.

Решением может опять выступать блокировка на смену состояния. Например, мютекс должен захватить парикмахер, чтобы закончить стрижку и пойти проверять зал ожидания и отпустить его, когда пойдет работать или спать. Тот же мютекс должен взять клиент, чтобы войти и проверить обстановку и отпустить, когда пойдет стричься или ждать.

У задачи есть усложнение в виде нескольких парикмахеров, проблемы синхронизации в этом случае усугубляются.

3. Задача о кукольных мастерах
В оригинале она о курильщиках (если вы захотите погуглить), но мы заменим этот термин для приличия. 
Итак у нас есть три мастера, каждый из них собирает кукол, кроме того, у каждого из них есть бесконечный запас частей одного вида -- рук, ног или туловищ. Им помогает четвертый мастер, который выдает головы. 
Если он видит, что стул пустой, он случайным (неодинаковым) образом выбирает двух мастеров и берет у них ресурсы. После чего добавляет очередную голову и кладет на стол. Когда мастер с недостающей частью видит, что на столе есть все необходимое, он это забирает и некоторое время собирает куклу. Пока он работает, новых деталей на стол не добавляют.

Решение (пример для мастера с ногами):
* взять тело
* взять руки
* взять голову
* собрать куклу

В таком случае мы получаем потенциальный дедлок, так как мастер с руками тоже может взять тело, а мастер с ногами взять руки, таким образом никто из них не сможет продолжить работу. Кроме того мастера могут одновременно попытаться взять нужные им ресурсы. 
Тут также стоит задача синхронизации проверок и взятия.

4. Задача о читателях и писателях
У этой задачи обычно нет более красивой легенды, но проблема все еще есть.  
У нас есть рукопись и две группы -- читатели и писатели. Читатели хотят прочитать ее, а писатели редактировать. \
Тут опять появляется проблема одновременного редактирования и возможности застать рукопись в некорректном состоянии (когда ее начали править, но не закончили). Тогда мы можем ограничить все взаимодействие с рукописью одной блокировкой, но это не самый быстрый вариант. \
Если читатель уже начал читать рукопись, второй читатель может к нему присоединиться, так как они не влияют друга на друга и на рукопись. В случае же с писателями никто больше не может одновременно иметь доступ к рукописи. Для этого подойдет [shared_mutex](https://en.cppreference.com/w/cpp/thread/shared_mutex), который поддерживает общую блокировку, которую может взять любое количество потоков, и эксклюзивную, которую может взять только 1 поток. Если хотя бы один поток взял общую блокировку, то эксклюзивную взять не получится. (только в случае, если ровно один этот поток и взял общую)