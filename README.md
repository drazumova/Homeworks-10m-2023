## Задачки для самостоятельного решения на паре 11.03

Для сдачи необходимо сделать в своем репозитории отдельную ветку. 
Если у Вас fork этого репозитория, то откройте pull request в него с любым названием на ваш выбор, содержащим ваши имя и фамилию. Если `fork`а нет, пришлите мне ссылку на `pull request` внутри вашего репозитория любым удобным способом.

Названия файлов и коммитов по возможности должны описывать их содержимое. То есть `1.cpp` или `sum.cpp` при желании можно связать с первой задачей, а файлы с именами `bulka.cpp` и `hlep.c` -- нет. Аналогично для сообщений коммитов.

Дорешивать дома задачи будет нельзя, работа оценивается. 

### Условия

1. На вход программе дается число $0 < n \le 10^6$ и $n$ целых неотрицательных чисел $\le 10^15$. В следующей строке дано целое положительное число $M \le 10^15$. \
Напишите программу, которая вычисляет сумму введенных чисел по модулю $M$. Считать сумму требуется, конечно, с помощью многопоточного программирования. При вычислении суммы $n$ чисел, они делятся на $3$ примерно равные по количеству элементов и аналогично рекурсивно считает их сумму, после чего складывает три значения и возвращает результат. Если $n$ чисел невозможно разделить на три части, вычислите сумму любым удобным вам способом.
2. На вход программе дается два файла (полных пути до них). Для каждого из них создается поток, который читает его по строкам. В каждой строке содержится последовательность нуклеотидов (символов `A`, `T`, `G`, `C`) одинаковой длины, обозначим ее $k$. \
Глобальная цель -- соединить в пары `(s1, s2)` так, чтобы суффикс длины $k-1$ строки `s1` был префиксом строки `s2`. \
Первый поток построчно считывает записи с последовательностями из первого файла и сохраняет их. \
Второй поток считывает строки из второго файла соответственно, но после считывания не идет дальше, пока не найдет в строках из первого файла подходящее пересечение. Если так случилось, что первый файл уже закончился, а пары для строки все еще не нашлось, то мы можем выкинуть строку и пойти дальше. \
У каждой строки может быть только одна пара. Мы в пару всегда ставим первую подходящую последовательность, не будем задумываться о том, что это может уменьшить количество созданных пар. \
После прочтения обоих файлов программа должна вывести пары последовательностей, который удалось найти. По одной паре в каждой строке.
3. При обновлении кеша есть несколько подходов к удалению других ключей, если новое значение не помещается
в выделенную память. В этой задаче мы выберем вариант, где удаляет ключ, к которому обращались последним.
Самостоятельно реализуйте класс для хранения такого кеша. При создании на вход дается количество ячеек, доступных для хранения. Для простоты давайте считать, что и ключи, и значения имеют тип целого числа. \
У класса должны быть следующие методы:
* `set(key, value)` -- добавить в кеш значение `value` по ключу `key`. Если такого ключа нет, то значение добавляется по логике описанной выше, иначе значение по ключу `key` обновляется. 
* `get(key)` -- получить значение по ключу `key`, если такого значения нет, вернуть `null`
любое обращению по ключу (`set` или `get`). 
* `score()` -- получить процент удачных запросов. То есть процент случаев обращение к кешу, когда такой ключ 
был найден в кеше. 

Конечно, обращения должны быть безопасны для использования в нескольких потоках.